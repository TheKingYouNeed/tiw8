// Variables globales pour g√©rer la connexion WebRTC
var name,                     // Stocke le code unique de l'utilisateur
    connectedUser,            // Stocke le code de l'utilisateur connect√©
    isInitiator = false,      // Bool√©en indiquant si on est √† l'origine de la connexion
    yourConnection,           // Objet RTCPeerConnection
    dataChannel,              // Canal de donn√©es pour l'√©change de fichiers
    currentFile,              // Fichier en cours de transfert
    currentFileSize,          // Taille du fichier en cours
    currentFileMeta;          // M√©tadonn√©es du fichier

// 1) Connexion au serveur de signaling (WebSocket)
var ip = window.location.hostname;  // R√©cup√®re l'IP du serveur depuis l'URL
console.log(ip);

// Cr√©e la connexion WebSocket vers le serveur
// Note: L'IP doit √™tre celle de la machine h√©bergeant le serveur
var connection = new WebSocket('ws://' + ip + ':8888');

// Pour se connecter depuis un autre PC : http://[IP_PC1]:8000

// Callback appel√© quand la connexion WebSocket est √©tablie
connection.onopen = function () {
  console.log("üîó Connected to signaling server");
  send({ type: "login" });  // Envoie une demande de login au serveur
};

// Callback pour g√©rer les messages re√ßus du serveur
connection.onmessage = function (message) {
  console.log("üì® Got message", message.data);
  var data = JSON.parse(message.data);  // Parse le message JSON

  // Traite le message selon son type
  switch (data.type) {
    case "login":
      onLogin(data);      // R√©ponse √† la connexion
      break;
    case "offer":
      onOffer(data.offer, data.name);  // Offre de connexion WebRTC
      break;
    case "answer":
      onAnswer(data.answer);           // R√©ponse √† l'offre
      break;
    case "candidate":
      onCandidate(data.candidate);     // Candidat ICE
      break;
    case "leave":
      onLeave();                       // D√©connexion
      break;
    default:
      break;
  }
};

// Callback pour g√©rer les erreurs de connexion WebSocket
connection.onerror = function (err) {
  console.error("‚ö† Got error", err);
};

// Envoi JSON via WebSocket
function send(message) {
  // Ajoute le nom de l'utilisateur connect√© si disponible
  if (connectedUser) {
    message.name = connectedUser;
  }
  // Envoie le message stringifi√©
  connection.send(JSON.stringify(message));
}

// 2) Traitement de la r√©ponse "login" du serveur
function onLogin(data) {
  name = data.code;  // R√©cup√®re le code unique
  $("#yourCode").text(name);  // Affiche le code dans l'UI
  console.log("üîë Logged in as", name);
  startConnection();  // Initialise la connexion WebRTC
}

// 3) Initialisation de la PeerConnection WebRTC
function startConnection() {
  // V√©rifie la compatibilit√© WebRTC
  if (!hasRTCPeerConnection()) {
    alert("Sorry, your browser does not support WebRTC.");
    return;
  }

  console.log("üì° Starting WebRTC peer connection");

  // Configuration des serveurs ICE (STUN/TURN)
  var configuration = {
    iceServers: [
      { url: "stun:stun.l.google.com:19302" }  // Serveur STUN public de Google
    ]
  };

  // Cr√©e la connexion peer-to-peer
  yourConnection = new RTCPeerConnection(configuration, { optional: [] });

  // a) Gestion des candidats ICE locaux
  yourConnection.onicecandidate = function (event) {
    if (event.candidate) {
      console.log("üßä ICE candidate generated:", event.candidate);
      send({ type: "candidate", candidate: event.candidate });  // Envoie au pair
    }
  };

  // b) Gestion du DataChannel pour le pair distant
  yourConnection.ondatachannel = function (event) {
    console.log("üì• DataChannel re√ßu");
    dataChannel = event.channel;
    setupDataChannelHandlers();  // Configure les handlers du canal
  };
}

// 4) Fonction appel√©e quand on clique sur "Connect"
function connect() {
  var otherDeviceCode = $("#otherDeviceCode").val();
  if (!otherDeviceCode) return;  // V√©rifie qu'un code a √©t√© saisi

  connectedUser = otherDeviceCode;
  isInitiator = true;  // On devient l'initiateur
  console.log("üìû D√©but de l'offre vers", connectedUser);

  // Cr√©e le DataChannel (c√¥t√© initiateur seulement)
  dataChannel = yourConnection.createDataChannel("myLabel");
  setupDataChannelHandlers();

  // On cr√©e l‚Äôoffre WebRTC
  yourConnection.createOffer(
    function (offer) {
      yourConnection.setLocalDescription(offer);
      send({ type: "offer", offer: offer });
    },
    function (error) {
      alert("Error when creating an offer");
    }
  );
}

// Mettre √† jour l‚ÄôUI pour d√©connecter
function disconnect() {
  console.log("üíî Envoi d‚Äôun leave √†", connectedUser);
  send({ type: "leave" });
  onLeave();
}


// 5) Traitement d‚Äôune ‚Äúoffer‚Äù

function onOffer(offer, name) {
  // je suis le callee
  connectedUser = name;
  isInitiator = false;
  console.log("üì® Offre re√ßue de", name);

  // Je configure mes handlers avant de g√©n√©rer la r√©ponse
  yourConnection.setRemoteDescription(new RTCSessionDescription(offer));

  // Je cr√©e la r√©ponse (answer)
  yourConnection.createAnswer(
    function (answer) {
      console.log("üì§ R√©ponse g√©n√©r√©e vers", connectedUser);
      yourConnection.setLocalDescription(answer);
      send({ type: "answer", answer: answer });
    },
    function (error) {
      alert("Error when creating an answer");
    }
  );
}


// 6) Traitement d‚Äôune ‚Äúanswer‚Äù

function onAnswer(answer) {
  console.log("üìÑ R√©ponse re√ßue ; d√©finition du remoteDescription");
  yourConnection.setRemoteDescription(new RTCSessionDescription(answer));
}


// 7) Traitement d‚Äôune ‚Äúcandidate‚Äù

function onCandidate(candidate) {
  console.log("üßä Ajout d‚Äôun ICE candidate re√ßu");
  yourConnection.addIceCandidate(new RTCIceCandidate(candidate));
}


// 8) Traitement d‚Äôun ‚Äúleave‚Äù

function onLeave() {
  console.log("üì¥ L‚Äôautre utilisateur a quitt√© la connexion");
  connectedUser = null;
  // Ferme et r√©initialise la connexion
  if (yourConnection) {
    yourConnection.close();
    yourConnection.onicecandidate = null;
  }
  // On peut recr√©er PeerConnection si on veut se reconnecter
  startConnection();
}


// 9) D√®s que le DataChannel existe (initiateur ou callee), on installe onmessage, onopen, onclose, etc.

function setupDataChannelHandlers() {
  dataChannel.onerror = function (error) {
    console.error("‚ö† Data Channel Error:", error);
  };

  dataChannel.onmessage = function (event) {
    try {
      var message = JSON.parse(event.data);
      switch (message.type) {
        case "start":
          currentFile = [];
          currentFileSize = 0;
          currentFileMeta = message.data;
          console.log("üì• D√©but de la r√©ception de ‚Äú" + currentFileMeta.name + "‚Äù (" + currentFileMeta.size + " octets)");
          break;
        case "end":
          console.log("‚úÖ Tous les chunks re√ßus pour ‚Äú" + currentFileMeta.name + "‚Äù : reconstitution du fichier");
          saveFile(currentFileMeta, currentFile);
          break;
      }
    } catch (e) {
      // C‚Äôest un chunk Base64
      currentFile.push(atob(event.data));
      currentFileSize += currentFile[currentFile.length - 1].length;
      var percentage = Math.floor((currentFileSize / currentFileMeta.size) * 100);
      console.log("üîÑ R√©ception chunk : " + percentage + "%");
      // Si vous aviez une barre HTML : 
      // $("#progress-recv").attr("aria-valuenow", percentage).css("width", percentage + "%");
    }
  };

  dataChannel.onopen = function () {
    console.log("üü¢ DataChannel open");
    $("#btn-disconnect").removeAttr("disabled");
    $("#btn-connect").attr("disabled", "disabled")
                     .removeClass("btn-default")
                     .addClass("btn-success")
                     .text("Connected to " + connectedUser);

    $("#otherDeviceCode").val("").attr("disabled", "disabled");
    $("#files-box").removeClass("hidden");
  };

  dataChannel.onclose = function () {
    console.log("üî¥ DataChannel closed");
    $("#btn-disconnect").attr("disabled", "disabled");

    $("#btn-connect").removeAttr("disabled")
                     .addClass("btn-default")
                     .removeClass("btn-success")
                     .text("Connect");

    $("#otherDeviceCode").val("").removeAttr("disabled");
    $("#files-box").addClass("hidden");
  };
}


// 10) Envoi du fichier c√¥t√© exp√©diteur

var CHUNK_MAX = 160000;
function sendFile(file, fileId) {
  var reader = new FileReader();

  reader.onloadend = function(evt) {
    if (evt.target.readyState !== FileReader.DONE) return;
    var buffer = reader.result,
        start = 0,
        end = 0,
        last = false;

    function sendChunk() {
      end = start + CHUNK_MAX;
      if (end > file.size) {
        end = file.size;
        last = true;
      }
      var pct = Math.floor((end / file.size) * 100);
      $("#file-" + fileId + " .progress-bar")
        .attr("aria-valuenow", pct)
        .css("width", pct + "%");
      dataChannel.send(arrayBufferToBase64(buffer.slice(start, end)));
      console.log("üì§ Envoi chunk : " + pct + "%");

      if (last) {
        dataChannel.send(JSON.stringify({ type: "end" }));
        console.log("üì§ Tous les chunks ont √©t√© envoy√©s (" + file.name + ")");
        startSending();
        $(".btn-remove-file-" + fileId)
          .removeClass("btn-warning")
          .addClass("btn-success")
          .attr("onclick", "")
          .attr("disabled", "disabled")
          .text("success");
      } else {
        start = end;
        setTimeout(sendChunk, 100);
      }
    }

    // Avant d‚Äôenvoyer les chunks, on envoie le JSON ‚Äústart‚Äù
    dataChannel.send(JSON.stringify({
      type: "start",
      data: {
        name: file.name,
        size: file.size,
        type: file.type,
        lastModified: file.lastModified,
        lastModifiedDate: file.lastModifiedDate
      }
    }));
    console.log("üì§ Envoi du message ‚Äústart‚Äù pour", file.name);
    // Puis on commence √† envoyer les lumps
    sendChunk();
  };

  reader.readAsArrayBuffer(file);
}


// Fonctions utilitaires

function saveFile(meta, data) {
  var blob = base64ToBlob(data, meta.type);
  console.log("üíæ Enregistrement du fichier re√ßu en tant que :", meta.name);
  saveAs(blob, meta.name);
}

function arrayBufferToBase64(buffer) {
  var binary = "";
  var bytes = new Uint8Array(buffer);
  for (var i = 0; i < bytes.byteLength; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return btoa(binary);
}

function base64ToBlob(b64Data, contentType) {
  contentType = contentType || "";
  var byteArrays = [];
  for (var i = 0; i < b64Data.length; i++) {
    var slice = b64Data[i];
    var byteNumbers = new Array(slice.length);
    for (var n = 0; n < slice.length; n++) {
      byteNumbers[n] = slice.charCodeAt(n);
    }
    byteArrays.push(new Uint8Array(byteNumbers));
  }
  return new Blob(byteArrays, { type: contentType });
}
// Fonction utilitaire pour v√©rifier la compatibilit√© WebRTC
function hasRTCPeerConnection() {

  // Normalise les pr√©fixes navigateurs
  
  window.RTCPeerConnection = window.RTCPeerConnection ||
                             window.webkitRTCPeerConnection ||
                             window.mozRTCPeerConnection;
  window.RTCSessionDescription = window.RTCSessionDescription ||
                                 window.webkitRTCSessionDescription ||
                                 window.mozRTCSessionDescription;
  window.RTCIceCandidate = window.RTCIceCandidate ||
                           window.webkitRTCIceCandidate ||
                           window.mozRTCIceCandidate;
  return !!window.RTCPeerConnection;
}

function hasFileApi() {
  return window.File && window.FileReader && window.FileList && window.Blob;
}
// No need to duplicate file handling code here as it's already in main.js
// The main.js file handles all file selection, listing, and UI updates

// We'll just leave the sendFile function since it works with the WebRTC dataChannel
// This way main.js can call it, but the actual file sending happens here with the dataChannel
